const { buildMarker } = require('./issues');

function branchName(vulnId) {
  return `thr8/fix-${vulnId.toLowerCase()}`;
}

function buildPRBody(vulnId, fixData, risk) {
  const lines = [
    buildMarker(vulnId),
    '',
    '## What was fixed',
    '',
    fixData.explanation || 'Automated security fix generated by thr8.',
    '',
  ];

  if (risk) {
    lines.push('## Risk Context', '');
    lines.push(`- **Risk Level:** ${risk.pasta_level}`);
    lines.push(`- **Business Impact:** ${risk.business_impact}`);
    lines.push('');
  }

  if (fixData.files && fixData.files.length > 0) {
    lines.push('## Files Changed', '');
    for (const f of fixData.files) {
      lines.push(`- \`${f.path}\``);
    }
    lines.push('');
  }

  if (fixData.notes) {
    lines.push('## Notes', '', fixData.notes, '');
  }

  lines.push('---', '*Generated by [thr8](https://github.com/cybrking/thr8) threat model action*');

  return lines.join('\n');
}

async function findExistingPR(octokit, context, vulnId) {
  const { owner, repo } = context.repo;
  const branch = branchName(vulnId);

  try {
    const { data: prs } = await octokit.rest.pulls.list({
      owner,
      repo,
      head: `${owner}:${branch}`,
      state: 'open',
      per_page: 1,
    });
    return prs.length > 0 ? prs[0] : null;
  } catch {
    return null;
  }
}

async function createFixPR(octokit, context, vulnId, fixData, risk) {
  const { owner, repo } = context.repo;
  const branch = branchName(vulnId);

  const existing = await findExistingPR(octokit, context, vulnId);
  if (existing) {
    return { created: false, pr: existing };
  }

  // Get default branch SHA
  const { data: repoData } = await octokit.rest.repos.get({ owner, repo });
  const defaultBranch = repoData.default_branch;
  const { data: ref } = await octokit.rest.git.getRef({
    owner,
    repo,
    ref: `heads/${defaultBranch}`,
  });
  const baseSha = ref.object.sha;

  // Create branch
  try {
    await octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branch}`,
      sha: baseSha,
    });
  } catch (err) {
    // Branch may already exist from a prior failed attempt — update it
    if (err.status === 422) {
      await octokit.rest.git.updateRef({
        owner,
        repo,
        ref: `heads/${branch}`,
        sha: baseSha,
        force: true,
      });
    } else {
      throw err;
    }
  }

  // Commit files
  for (const file of fixData.files) {
    // Get current file content for the sha
    let fileSha;
    try {
      const { data: existing } = await octokit.rest.repos.getContent({
        owner,
        repo,
        path: file.path,
        ref: branch,
      });
      fileSha = existing.sha;
    } catch {
      // File doesn't exist yet, that's ok
    }

    await octokit.rest.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: file.path,
      message: `fix: ${vulnId} — ${fixData.explanation || 'security fix'}`.slice(0, 72),
      content: Buffer.from(file.fixed_content).toString('base64'),
      branch,
      ...(fileSha ? { sha: fileSha } : {}),
    });
  }

  // Create PR
  const title = `[thr8] Fix ${vulnId}`;
  const body = buildPRBody(vulnId, fixData, risk);

  const { data: pr } = await octokit.rest.pulls.create({
    owner,
    repo,
    title,
    body,
    head: branch,
    base: defaultBranch,
  });

  return { created: true, pr };
}

module.exports = {
  createFixPR,
  findExistingPR,
  buildPRBody,
  branchName,
};
